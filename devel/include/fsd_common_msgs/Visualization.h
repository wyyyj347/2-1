// Generated by gencpp from file fsd_common_msgs/Visualization.msg
// DO NOT EDIT!


#ifndef FSD_COMMON_MSGS_MESSAGE_VISUALIZATION_H
#define FSD_COMMON_MSGS_MESSAGE_VISUALIZATION_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace fsd_common_msgs
{
template <class ContainerAllocator>
struct Visualization_
{
  typedef Visualization_<ContainerAllocator> Type;

  Visualization_()
    : header()
    , frame_id_num(0)
    , lat_error_front_axis(0.0)
    , lat_error_cog(0.0)
    , lat_error_rear_axis(0.0)
    , yaw_error_front_axis(0.0)
    , yaw_error_cog(0.0)
    , yaw_error_rear_axis(0.0)
    , yaw_rate_error(0.0)
    , steering_error(0.0)
    , vx_error(0.0)
    , vy_error(0.0)
    , sideslip_error(0.0)
    , motor_torq_error_lr(0.0)
    , motor_torq_error_rr(0.0)
    , motor_speed_error_lr(0.0)
    , motor_speed_error_rr(0.0)
    , error1(0.0)
    , error2(0.0)
    , error3(0.0)
    , error4(0.0)
    , yaw_ref(0.0)
    , yaw_ref_front_axis(0.0)
    , yaw_ref_cog(0.0)
    , yaw_ref_rear_axis(0.0)
    , curvature_ref(0.0)
    , curvature_ref_front_axis(0.0)
    , curvature_ref_cog(0.0)
    , curvature_ref_rear_axis(0.0)
    , vx_ref(0.0)
    , vy_ref(0.0)
    , ax_ref(0.0)
    , ay_ref(0.0)
    , ref1(0.0)
    , ref2(0.0)
    , ref3(0.0)
    , ref4(0.0)
    , steering_without_compensation(0.0)
    , steering_feedback(0.0)
    , steering_feedforward(0.0)
    , lookforward_length(0.0)
    , yaw_rate_pre(0.0)
    , turning_radius(0.0)
    , adhesion_coefficient_pre(0.0)
    , sideslip_pre(0.0)
    , slip_angle_pre_fl(0.0)
    , slip_angle_pre_fr(0.0)
    , slip_angle_pre_rl(0.0)
    , slip_angle_pre_rr(0.0)
    , norm_force_pre_fl(0.0)
    , norm_force_pre_fr(0.0)
    , norm_force_pre_rl(0.0)
    , norm_force_pre_rr(0.0)
    , algorithm1(0.0)
    , algorithm2(0.0)
    , algorithm3(0.0)
    , algorithm4(0.0)  {
    }
  Visualization_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , frame_id_num(0)
    , lat_error_front_axis(0.0)
    , lat_error_cog(0.0)
    , lat_error_rear_axis(0.0)
    , yaw_error_front_axis(0.0)
    , yaw_error_cog(0.0)
    , yaw_error_rear_axis(0.0)
    , yaw_rate_error(0.0)
    , steering_error(0.0)
    , vx_error(0.0)
    , vy_error(0.0)
    , sideslip_error(0.0)
    , motor_torq_error_lr(0.0)
    , motor_torq_error_rr(0.0)
    , motor_speed_error_lr(0.0)
    , motor_speed_error_rr(0.0)
    , error1(0.0)
    , error2(0.0)
    , error3(0.0)
    , error4(0.0)
    , yaw_ref(0.0)
    , yaw_ref_front_axis(0.0)
    , yaw_ref_cog(0.0)
    , yaw_ref_rear_axis(0.0)
    , curvature_ref(0.0)
    , curvature_ref_front_axis(0.0)
    , curvature_ref_cog(0.0)
    , curvature_ref_rear_axis(0.0)
    , vx_ref(0.0)
    , vy_ref(0.0)
    , ax_ref(0.0)
    , ay_ref(0.0)
    , ref1(0.0)
    , ref2(0.0)
    , ref3(0.0)
    , ref4(0.0)
    , steering_without_compensation(0.0)
    , steering_feedback(0.0)
    , steering_feedforward(0.0)
    , lookforward_length(0.0)
    , yaw_rate_pre(0.0)
    , turning_radius(0.0)
    , adhesion_coefficient_pre(0.0)
    , sideslip_pre(0.0)
    , slip_angle_pre_fl(0.0)
    , slip_angle_pre_fr(0.0)
    , slip_angle_pre_rl(0.0)
    , slip_angle_pre_rr(0.0)
    , norm_force_pre_fl(0.0)
    , norm_force_pre_fr(0.0)
    , norm_force_pre_rl(0.0)
    , norm_force_pre_rr(0.0)
    , algorithm1(0.0)
    , algorithm2(0.0)
    , algorithm3(0.0)
    , algorithm4(0.0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint64_t _frame_id_num_type;
  _frame_id_num_type frame_id_num;

   typedef float _lat_error_front_axis_type;
  _lat_error_front_axis_type lat_error_front_axis;

   typedef float _lat_error_cog_type;
  _lat_error_cog_type lat_error_cog;

   typedef float _lat_error_rear_axis_type;
  _lat_error_rear_axis_type lat_error_rear_axis;

   typedef float _yaw_error_front_axis_type;
  _yaw_error_front_axis_type yaw_error_front_axis;

   typedef float _yaw_error_cog_type;
  _yaw_error_cog_type yaw_error_cog;

   typedef float _yaw_error_rear_axis_type;
  _yaw_error_rear_axis_type yaw_error_rear_axis;

   typedef float _yaw_rate_error_type;
  _yaw_rate_error_type yaw_rate_error;

   typedef float _steering_error_type;
  _steering_error_type steering_error;

   typedef float _vx_error_type;
  _vx_error_type vx_error;

   typedef float _vy_error_type;
  _vy_error_type vy_error;

   typedef float _sideslip_error_type;
  _sideslip_error_type sideslip_error;

   typedef float _motor_torq_error_lr_type;
  _motor_torq_error_lr_type motor_torq_error_lr;

   typedef float _motor_torq_error_rr_type;
  _motor_torq_error_rr_type motor_torq_error_rr;

   typedef float _motor_speed_error_lr_type;
  _motor_speed_error_lr_type motor_speed_error_lr;

   typedef float _motor_speed_error_rr_type;
  _motor_speed_error_rr_type motor_speed_error_rr;

   typedef float _error1_type;
  _error1_type error1;

   typedef float _error2_type;
  _error2_type error2;

   typedef float _error3_type;
  _error3_type error3;

   typedef float _error4_type;
  _error4_type error4;

   typedef float _yaw_ref_type;
  _yaw_ref_type yaw_ref;

   typedef float _yaw_ref_front_axis_type;
  _yaw_ref_front_axis_type yaw_ref_front_axis;

   typedef float _yaw_ref_cog_type;
  _yaw_ref_cog_type yaw_ref_cog;

   typedef float _yaw_ref_rear_axis_type;
  _yaw_ref_rear_axis_type yaw_ref_rear_axis;

   typedef float _curvature_ref_type;
  _curvature_ref_type curvature_ref;

   typedef float _curvature_ref_front_axis_type;
  _curvature_ref_front_axis_type curvature_ref_front_axis;

   typedef float _curvature_ref_cog_type;
  _curvature_ref_cog_type curvature_ref_cog;

   typedef float _curvature_ref_rear_axis_type;
  _curvature_ref_rear_axis_type curvature_ref_rear_axis;

   typedef float _vx_ref_type;
  _vx_ref_type vx_ref;

   typedef float _vy_ref_type;
  _vy_ref_type vy_ref;

   typedef float _ax_ref_type;
  _ax_ref_type ax_ref;

   typedef float _ay_ref_type;
  _ay_ref_type ay_ref;

   typedef float _ref1_type;
  _ref1_type ref1;

   typedef float _ref2_type;
  _ref2_type ref2;

   typedef float _ref3_type;
  _ref3_type ref3;

   typedef float _ref4_type;
  _ref4_type ref4;

   typedef float _steering_without_compensation_type;
  _steering_without_compensation_type steering_without_compensation;

   typedef float _steering_feedback_type;
  _steering_feedback_type steering_feedback;

   typedef float _steering_feedforward_type;
  _steering_feedforward_type steering_feedforward;

   typedef float _lookforward_length_type;
  _lookforward_length_type lookforward_length;

   typedef float _yaw_rate_pre_type;
  _yaw_rate_pre_type yaw_rate_pre;

   typedef float _turning_radius_type;
  _turning_radius_type turning_radius;

   typedef float _adhesion_coefficient_pre_type;
  _adhesion_coefficient_pre_type adhesion_coefficient_pre;

   typedef float _sideslip_pre_type;
  _sideslip_pre_type sideslip_pre;

   typedef float _slip_angle_pre_fl_type;
  _slip_angle_pre_fl_type slip_angle_pre_fl;

   typedef float _slip_angle_pre_fr_type;
  _slip_angle_pre_fr_type slip_angle_pre_fr;

   typedef float _slip_angle_pre_rl_type;
  _slip_angle_pre_rl_type slip_angle_pre_rl;

   typedef float _slip_angle_pre_rr_type;
  _slip_angle_pre_rr_type slip_angle_pre_rr;

   typedef float _norm_force_pre_fl_type;
  _norm_force_pre_fl_type norm_force_pre_fl;

   typedef float _norm_force_pre_fr_type;
  _norm_force_pre_fr_type norm_force_pre_fr;

   typedef float _norm_force_pre_rl_type;
  _norm_force_pre_rl_type norm_force_pre_rl;

   typedef float _norm_force_pre_rr_type;
  _norm_force_pre_rr_type norm_force_pre_rr;

   typedef float _algorithm1_type;
  _algorithm1_type algorithm1;

   typedef float _algorithm2_type;
  _algorithm2_type algorithm2;

   typedef float _algorithm3_type;
  _algorithm3_type algorithm3;

   typedef float _algorithm4_type;
  _algorithm4_type algorithm4;





  typedef boost::shared_ptr< ::fsd_common_msgs::Visualization_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::fsd_common_msgs::Visualization_<ContainerAllocator> const> ConstPtr;

}; // struct Visualization_

typedef ::fsd_common_msgs::Visualization_<std::allocator<void> > Visualization;

typedef boost::shared_ptr< ::fsd_common_msgs::Visualization > VisualizationPtr;
typedef boost::shared_ptr< ::fsd_common_msgs::Visualization const> VisualizationConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::fsd_common_msgs::Visualization_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::fsd_common_msgs::Visualization_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::fsd_common_msgs::Visualization_<ContainerAllocator1> & lhs, const ::fsd_common_msgs::Visualization_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.frame_id_num == rhs.frame_id_num &&
    lhs.lat_error_front_axis == rhs.lat_error_front_axis &&
    lhs.lat_error_cog == rhs.lat_error_cog &&
    lhs.lat_error_rear_axis == rhs.lat_error_rear_axis &&
    lhs.yaw_error_front_axis == rhs.yaw_error_front_axis &&
    lhs.yaw_error_cog == rhs.yaw_error_cog &&
    lhs.yaw_error_rear_axis == rhs.yaw_error_rear_axis &&
    lhs.yaw_rate_error == rhs.yaw_rate_error &&
    lhs.steering_error == rhs.steering_error &&
    lhs.vx_error == rhs.vx_error &&
    lhs.vy_error == rhs.vy_error &&
    lhs.sideslip_error == rhs.sideslip_error &&
    lhs.motor_torq_error_lr == rhs.motor_torq_error_lr &&
    lhs.motor_torq_error_rr == rhs.motor_torq_error_rr &&
    lhs.motor_speed_error_lr == rhs.motor_speed_error_lr &&
    lhs.motor_speed_error_rr == rhs.motor_speed_error_rr &&
    lhs.error1 == rhs.error1 &&
    lhs.error2 == rhs.error2 &&
    lhs.error3 == rhs.error3 &&
    lhs.error4 == rhs.error4 &&
    lhs.yaw_ref == rhs.yaw_ref &&
    lhs.yaw_ref_front_axis == rhs.yaw_ref_front_axis &&
    lhs.yaw_ref_cog == rhs.yaw_ref_cog &&
    lhs.yaw_ref_rear_axis == rhs.yaw_ref_rear_axis &&
    lhs.curvature_ref == rhs.curvature_ref &&
    lhs.curvature_ref_front_axis == rhs.curvature_ref_front_axis &&
    lhs.curvature_ref_cog == rhs.curvature_ref_cog &&
    lhs.curvature_ref_rear_axis == rhs.curvature_ref_rear_axis &&
    lhs.vx_ref == rhs.vx_ref &&
    lhs.vy_ref == rhs.vy_ref &&
    lhs.ax_ref == rhs.ax_ref &&
    lhs.ay_ref == rhs.ay_ref &&
    lhs.ref1 == rhs.ref1 &&
    lhs.ref2 == rhs.ref2 &&
    lhs.ref3 == rhs.ref3 &&
    lhs.ref4 == rhs.ref4 &&
    lhs.steering_without_compensation == rhs.steering_without_compensation &&
    lhs.steering_feedback == rhs.steering_feedback &&
    lhs.steering_feedforward == rhs.steering_feedforward &&
    lhs.lookforward_length == rhs.lookforward_length &&
    lhs.yaw_rate_pre == rhs.yaw_rate_pre &&
    lhs.turning_radius == rhs.turning_radius &&
    lhs.adhesion_coefficient_pre == rhs.adhesion_coefficient_pre &&
    lhs.sideslip_pre == rhs.sideslip_pre &&
    lhs.slip_angle_pre_fl == rhs.slip_angle_pre_fl &&
    lhs.slip_angle_pre_fr == rhs.slip_angle_pre_fr &&
    lhs.slip_angle_pre_rl == rhs.slip_angle_pre_rl &&
    lhs.slip_angle_pre_rr == rhs.slip_angle_pre_rr &&
    lhs.norm_force_pre_fl == rhs.norm_force_pre_fl &&
    lhs.norm_force_pre_fr == rhs.norm_force_pre_fr &&
    lhs.norm_force_pre_rl == rhs.norm_force_pre_rl &&
    lhs.norm_force_pre_rr == rhs.norm_force_pre_rr &&
    lhs.algorithm1 == rhs.algorithm1 &&
    lhs.algorithm2 == rhs.algorithm2 &&
    lhs.algorithm3 == rhs.algorithm3 &&
    lhs.algorithm4 == rhs.algorithm4;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::fsd_common_msgs::Visualization_<ContainerAllocator1> & lhs, const ::fsd_common_msgs::Visualization_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace fsd_common_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::fsd_common_msgs::Visualization_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::fsd_common_msgs::Visualization_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::fsd_common_msgs::Visualization_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e50abcd3e258993f1e09e11ebe66bc57";
  }

  static const char* value(const ::fsd_common_msgs::Visualization_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe50abcd3e258993fULL;
  static const uint64_t static_value2 = 0x1e09e11ebe66bc57ULL;
};

template<class ContainerAllocator>
struct DataType< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fsd_common_msgs/Visualization";
  }

  static const char* value(const ::fsd_common_msgs::Visualization_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# visualization data \n"
"Header header         # standard ROS message header\n"
"uint64 frame_id_num \n"
"\n"
"#error data \n"
"float32 lat_error_front_axis\n"
"float32 lat_error_cog\n"
"float32 lat_error_rear_axis\n"
"float32 yaw_error_front_axis\n"
"float32 yaw_error_cog\n"
"float32 yaw_error_rear_axis\n"
"float32 yaw_rate_error\n"
"float32 steering_error\n"
"float32 vx_error\n"
"float32 vy_error\n"
"float32 sideslip_error\n"
"float32 motor_torq_error_lr\n"
"float32 motor_torq_error_rr\n"
"float32 motor_speed_error_lr\n"
"float32 motor_speed_error_rr\n"
"float32 error1\n"
"float32 error2\n"
"float32 error3\n"
"float32 error4\n"
"\n"
"#ref visualization\n"
"float32 yaw_ref\n"
"float32 yaw_ref_front_axis\n"
"float32 yaw_ref_cog\n"
"float32 yaw_ref_rear_axis\n"
"float32 curvature_ref\n"
"float32 curvature_ref_front_axis\n"
"float32 curvature_ref_cog\n"
"float32 curvature_ref_rear_axis\n"
"float32 vx_ref\n"
"float32 vy_ref\n"
"float32 ax_ref\n"
"float32 ay_ref\n"
"float32 ref1\n"
"float32 ref2\n"
"float32 ref3\n"
"float32 ref4\n"
"\n"
"#algorithm data visualization\n"
"float32 steering_without_compensation\n"
"float32 steering_feedback\n"
"float32 steering_feedforward\n"
"float32 lookforward_length\n"
"float32 yaw_rate_pre\n"
"float32 turning_radius\n"
"float32 adhesion_coefficient_pre\n"
"float32 sideslip_pre\n"
"float32 slip_angle_pre_fl\n"
"float32 slip_angle_pre_fr\n"
"float32 slip_angle_pre_rl\n"
"float32 slip_angle_pre_rr\n"
"float32 norm_force_pre_fl\n"
"float32 norm_force_pre_fr\n"
"float32 norm_force_pre_rl\n"
"float32 norm_force_pre_rr\n"
"float32 algorithm1\n"
"float32 algorithm2\n"
"float32 algorithm3\n"
"float32 algorithm4\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::fsd_common_msgs::Visualization_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.frame_id_num);
      stream.next(m.lat_error_front_axis);
      stream.next(m.lat_error_cog);
      stream.next(m.lat_error_rear_axis);
      stream.next(m.yaw_error_front_axis);
      stream.next(m.yaw_error_cog);
      stream.next(m.yaw_error_rear_axis);
      stream.next(m.yaw_rate_error);
      stream.next(m.steering_error);
      stream.next(m.vx_error);
      stream.next(m.vy_error);
      stream.next(m.sideslip_error);
      stream.next(m.motor_torq_error_lr);
      stream.next(m.motor_torq_error_rr);
      stream.next(m.motor_speed_error_lr);
      stream.next(m.motor_speed_error_rr);
      stream.next(m.error1);
      stream.next(m.error2);
      stream.next(m.error3);
      stream.next(m.error4);
      stream.next(m.yaw_ref);
      stream.next(m.yaw_ref_front_axis);
      stream.next(m.yaw_ref_cog);
      stream.next(m.yaw_ref_rear_axis);
      stream.next(m.curvature_ref);
      stream.next(m.curvature_ref_front_axis);
      stream.next(m.curvature_ref_cog);
      stream.next(m.curvature_ref_rear_axis);
      stream.next(m.vx_ref);
      stream.next(m.vy_ref);
      stream.next(m.ax_ref);
      stream.next(m.ay_ref);
      stream.next(m.ref1);
      stream.next(m.ref2);
      stream.next(m.ref3);
      stream.next(m.ref4);
      stream.next(m.steering_without_compensation);
      stream.next(m.steering_feedback);
      stream.next(m.steering_feedforward);
      stream.next(m.lookforward_length);
      stream.next(m.yaw_rate_pre);
      stream.next(m.turning_radius);
      stream.next(m.adhesion_coefficient_pre);
      stream.next(m.sideslip_pre);
      stream.next(m.slip_angle_pre_fl);
      stream.next(m.slip_angle_pre_fr);
      stream.next(m.slip_angle_pre_rl);
      stream.next(m.slip_angle_pre_rr);
      stream.next(m.norm_force_pre_fl);
      stream.next(m.norm_force_pre_fr);
      stream.next(m.norm_force_pre_rl);
      stream.next(m.norm_force_pre_rr);
      stream.next(m.algorithm1);
      stream.next(m.algorithm2);
      stream.next(m.algorithm3);
      stream.next(m.algorithm4);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Visualization_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::fsd_common_msgs::Visualization_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::fsd_common_msgs::Visualization_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "frame_id_num: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.frame_id_num);
    s << indent << "lat_error_front_axis: ";
    Printer<float>::stream(s, indent + "  ", v.lat_error_front_axis);
    s << indent << "lat_error_cog: ";
    Printer<float>::stream(s, indent + "  ", v.lat_error_cog);
    s << indent << "lat_error_rear_axis: ";
    Printer<float>::stream(s, indent + "  ", v.lat_error_rear_axis);
    s << indent << "yaw_error_front_axis: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_error_front_axis);
    s << indent << "yaw_error_cog: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_error_cog);
    s << indent << "yaw_error_rear_axis: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_error_rear_axis);
    s << indent << "yaw_rate_error: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_rate_error);
    s << indent << "steering_error: ";
    Printer<float>::stream(s, indent + "  ", v.steering_error);
    s << indent << "vx_error: ";
    Printer<float>::stream(s, indent + "  ", v.vx_error);
    s << indent << "vy_error: ";
    Printer<float>::stream(s, indent + "  ", v.vy_error);
    s << indent << "sideslip_error: ";
    Printer<float>::stream(s, indent + "  ", v.sideslip_error);
    s << indent << "motor_torq_error_lr: ";
    Printer<float>::stream(s, indent + "  ", v.motor_torq_error_lr);
    s << indent << "motor_torq_error_rr: ";
    Printer<float>::stream(s, indent + "  ", v.motor_torq_error_rr);
    s << indent << "motor_speed_error_lr: ";
    Printer<float>::stream(s, indent + "  ", v.motor_speed_error_lr);
    s << indent << "motor_speed_error_rr: ";
    Printer<float>::stream(s, indent + "  ", v.motor_speed_error_rr);
    s << indent << "error1: ";
    Printer<float>::stream(s, indent + "  ", v.error1);
    s << indent << "error2: ";
    Printer<float>::stream(s, indent + "  ", v.error2);
    s << indent << "error3: ";
    Printer<float>::stream(s, indent + "  ", v.error3);
    s << indent << "error4: ";
    Printer<float>::stream(s, indent + "  ", v.error4);
    s << indent << "yaw_ref: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_ref);
    s << indent << "yaw_ref_front_axis: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_ref_front_axis);
    s << indent << "yaw_ref_cog: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_ref_cog);
    s << indent << "yaw_ref_rear_axis: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_ref_rear_axis);
    s << indent << "curvature_ref: ";
    Printer<float>::stream(s, indent + "  ", v.curvature_ref);
    s << indent << "curvature_ref_front_axis: ";
    Printer<float>::stream(s, indent + "  ", v.curvature_ref_front_axis);
    s << indent << "curvature_ref_cog: ";
    Printer<float>::stream(s, indent + "  ", v.curvature_ref_cog);
    s << indent << "curvature_ref_rear_axis: ";
    Printer<float>::stream(s, indent + "  ", v.curvature_ref_rear_axis);
    s << indent << "vx_ref: ";
    Printer<float>::stream(s, indent + "  ", v.vx_ref);
    s << indent << "vy_ref: ";
    Printer<float>::stream(s, indent + "  ", v.vy_ref);
    s << indent << "ax_ref: ";
    Printer<float>::stream(s, indent + "  ", v.ax_ref);
    s << indent << "ay_ref: ";
    Printer<float>::stream(s, indent + "  ", v.ay_ref);
    s << indent << "ref1: ";
    Printer<float>::stream(s, indent + "  ", v.ref1);
    s << indent << "ref2: ";
    Printer<float>::stream(s, indent + "  ", v.ref2);
    s << indent << "ref3: ";
    Printer<float>::stream(s, indent + "  ", v.ref3);
    s << indent << "ref4: ";
    Printer<float>::stream(s, indent + "  ", v.ref4);
    s << indent << "steering_without_compensation: ";
    Printer<float>::stream(s, indent + "  ", v.steering_without_compensation);
    s << indent << "steering_feedback: ";
    Printer<float>::stream(s, indent + "  ", v.steering_feedback);
    s << indent << "steering_feedforward: ";
    Printer<float>::stream(s, indent + "  ", v.steering_feedforward);
    s << indent << "lookforward_length: ";
    Printer<float>::stream(s, indent + "  ", v.lookforward_length);
    s << indent << "yaw_rate_pre: ";
    Printer<float>::stream(s, indent + "  ", v.yaw_rate_pre);
    s << indent << "turning_radius: ";
    Printer<float>::stream(s, indent + "  ", v.turning_radius);
    s << indent << "adhesion_coefficient_pre: ";
    Printer<float>::stream(s, indent + "  ", v.adhesion_coefficient_pre);
    s << indent << "sideslip_pre: ";
    Printer<float>::stream(s, indent + "  ", v.sideslip_pre);
    s << indent << "slip_angle_pre_fl: ";
    Printer<float>::stream(s, indent + "  ", v.slip_angle_pre_fl);
    s << indent << "slip_angle_pre_fr: ";
    Printer<float>::stream(s, indent + "  ", v.slip_angle_pre_fr);
    s << indent << "slip_angle_pre_rl: ";
    Printer<float>::stream(s, indent + "  ", v.slip_angle_pre_rl);
    s << indent << "slip_angle_pre_rr: ";
    Printer<float>::stream(s, indent + "  ", v.slip_angle_pre_rr);
    s << indent << "norm_force_pre_fl: ";
    Printer<float>::stream(s, indent + "  ", v.norm_force_pre_fl);
    s << indent << "norm_force_pre_fr: ";
    Printer<float>::stream(s, indent + "  ", v.norm_force_pre_fr);
    s << indent << "norm_force_pre_rl: ";
    Printer<float>::stream(s, indent + "  ", v.norm_force_pre_rl);
    s << indent << "norm_force_pre_rr: ";
    Printer<float>::stream(s, indent + "  ", v.norm_force_pre_rr);
    s << indent << "algorithm1: ";
    Printer<float>::stream(s, indent + "  ", v.algorithm1);
    s << indent << "algorithm2: ";
    Printer<float>::stream(s, indent + "  ", v.algorithm2);
    s << indent << "algorithm3: ";
    Printer<float>::stream(s, indent + "  ", v.algorithm3);
    s << indent << "algorithm4: ";
    Printer<float>::stream(s, indent + "  ", v.algorithm4);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FSD_COMMON_MSGS_MESSAGE_VISUALIZATION_H
